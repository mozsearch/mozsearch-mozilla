#!/usr/bin/env bash

set -x # Show commands
set -eu # Errors/undefined vars are fatal
set -o pipefail # Check all commands in a pipeline

date

# NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
#
# >>> firefox-main is special because we like code coverage data! <<<
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# Unless a `TRYPUSH_REV` is specified below, we are going to use the
# `project.relman.code-coverage.production.repo.mozilla-central.latest` route
# in order to try and find a recent hg revision to use that has coverage.
#
# To do this, we are going to use a few taskcluster APIs directly via curl.
# Arguably, a better idea is to use the `taskcluster` binary, but we only
# actually need to hit 2 URLs here and so the moving parts theory favors not
# provisioning `taskcluster` yet, but it would probably be a reasonable step.

# This defaults to the most recent searchfox indexing run for mozilla-central
# which is still the name of the firefox-main tree for build purposes.
BUILD_REVISION_TREE=mozilla-central
BUILD_REVISION_ID=latest

TC_ROOT_URL=https://firefox-ci-tc.services.mozilla.com
TC_INDEX_API_URL=${TC_ROOT_URL}/api/index/v1/task
COVERAGE_ROUTE=project.relman.code-coverage.production.repo.${BUILD_REVISION_TREE}.latest
TC_QUEUE_API_URL=${TC_ROOT_URL}/api/queue/v1/task

# Set TRYPUSH_REV in the environment to e.g. ee64db93dcc149da9313460317257b8c42eec5b2
# or whatever to test a try revision. It needs to be the full rev hash, so that we can
# find the artifacts in taskcluster.
TRYPUSH_REV=${TRYPUSH_REV:-}
if [ -n "$TRYPUSH_REV" ]; then
    BUILD_REVISION_TREE=try
    BUILD_REVISION_ID="revision.${TRYPUSH_REV}"
    COV_HG_REV="$TRYPUSH_REV"
    echo "TRYPUSH_REV was used, ignoring coverage-based revision choice. Using: ${BUILD_REVISION_ID}"
else
    # find the taskId that the "latest" code coverage for our tree
    COV_TASKID=$(curl -ssL "${TC_INDEX_API_URL}/${COVERAGE_ROUTE}" | jq -Mr '.taskId')
    # get the task definition JSON and save it into a variable so we can pick
    # multiple fields out
    COV_TASK_INFO=$(curl -ssL "${TC_QUEUE_API_URL}/${COV_TASKID}")
    # The revision to index is passed specifically to the job
    COV_HG_REV=$(jq -Mr '.payload.env.REVISION' <<< $COV_TASK_INFO)

    # How many whole days have passed since the coverage aggregation task was
    # started and now?  If it's been less than a day (therefore "0"), the data
    # is good enough for our purposes.
    if [[ $COV_HG_REV = "null" ]]; then
        # In the failure mode we're seeing in Bug 1909053, COV_TASK_INFO is a
        # 404 JSON blob and we will have extracted null from it.  Let's just
        # pick a very obvious non-zero value so that we can just use the latest
        # indexed revision.
        echo "No sign of coverage data; pretending the data is stale."
        COV_RECENCY_DAYS=999
    else
        COV_RECENCY_DAYS=$(jq -Mr '.created | sub("\\.[0-9]+Z$"; "Z") | (now - fromdate) / (24 * 60 * 60) | floor' <<< $COV_TASK_INFO)
    fi

    if [[ $COV_RECENCY_DAYS = "0" ]]; then
        # We also need to check that the revision is itself recent enough, see
        # bug 1818083.
        COV_HG_REV_TARGET_INFO=$(curl -SsfL --compressed "${TC_INDEX_API_URL}/gecko.v2.${BUILD_REVISION_TREE}.revision.${COV_HG_REV}.firefox.linux64-searchfox-debug/artifacts/public/build/target.json")
        COV_BUILDID=$(jq -Mr .buildid <<< $COV_HG_REV_TARGET_INFO)
        COV_BUILDID_IS_RECENT=$(jq -Mr --arg today $(date +%Y%m%d) --arg yesterday $(date --date yesterday +%Y%m%d) '.buildid | startswith($today) or startswith($yesterday)' <<< $COV_HG_REV_TARGET_INFO)
        if [ $COV_BUILDID_IS_RECENT = "true" ]; then
            BUILD_REVISION_ID="revision.${COV_HG_REV}"
            echo "Coverage data is recent enough, using explicit revision: ${BUILD_REVISION_ID}"
        else
            echo "Coverage data is recent, but it's for an old revision (${COV_HG_REV}, ${COV_BUILDID}), sticking with: ${BUILD_REVISION_ID}"
        fi
    else
        echo "Coverage data is ${COV_RECENCY_DAYS} old, sticking with: ${BUILD_REVISION_ID}"
    fi
fi

# The next line populates the INDEXED_HG_REV and PREEXISTING_HG_REV env vars.
# Note that PREEXISTING_HG_REV will generally be empty in production.
source $CONFIG_REPO/firefox-shared/resolve-gecko-revs.sh $BUILD_REVISION_TREE $BUILD_REVISION_ID

$CONFIG_REPO/firefox-shared/checkout-gecko-repos.sh $BUILD_REVISION_TREE "main" "$INDEXED_HG_REV"

$CONFIG_REPO/firefox-shared/fetch-tc-artifacts.sh $BUILD_REVISION_TREE $INDEXED_HG_REV "$PREEXISTING_HG_REV" "$COV_HG_REV"

date

CODE_COVERAGE_REPORT="$INDEX_ROOT/code-coverage-report.json"
if [ -f "$CODE_COVERAGE_REPORT" ]; then
    mkdir -p "$COVERAGE_ROOT"
    COV_GIT_REV="$(git -C "$GIT_ROOT" cinnabar hg2git "$COV_HG_REV")"
    COV_DATE="$(git -C "$GIT_ROOT" show --no-patch --format=%cI "$COV_GIT_REV")"
    codecov2git --report "$CODE_COVERAGE_REPORT" --output-repo "$COVERAGE_ROOT" --commit "$COV_GIT_REV" --date "$COV_DATE"
fi

date

# Note that only $SHARED_BARE_GIT_ROOT diverges from the worktree $GIT_ROOT.
# We use these paths for clarity/consistency that we're working in bare-repo space.
SHARED_BARE_GIT_ROOT=$SHARED_ROOT/git
SHARED_BARE_OLDGIT_ROOT=$SHARED_ROOT/oldgit
SHARED_BARE_BLAME_ROOT=$SHARED_ROOT/blame

# Also generate blame for some other branches, because the blame repo is
# shared by those branches. We do this here instead of in e.g. ../firefox-beta/setup
# because it's best to have only one indexer instance responsible for updating and
# pushing the tarball to S3, to avoid accidental clobbers.
#

# --- Generate Branches with old searchfox permalink support
# DO NOT ADD NEW BRANCHES HERE AS-IS, Either create a forked version of this logic
# without use of `--old-cinnabar-repo-path` or remove that use here.  Specifically,
# we need to have fully moved off of the old mozilla-* branches for the below
# branches.
for BRANCH in main beta release esr140 esr128 esr115; do
    echo "Generating blame information for $BRANCH..."
    # Try and start from an existing blame branch if this is a new branch.  New
    # esr branches should look most like the release branch, and we expect other
    # branches in the future will probably be feature branches based off of
    # main.
    #
    # Some interesting historical notes for the initial firefox-* conversions:
    # - Building blame for "beta" off of "main" required ingesting blame for
    #   66,408 revisions.
    # - Building blame for "release" off of "beta" required ingesting blame for
    #   5,415 revisions.
    # - Building blame for "esr140" off of "release" required ingesting blame for
    #   227 revisions.
    # - Building blame for "esr128" off of "release" required ingesting blame for
    #   965 revisions.
    if [[ "$BRANCH" == esr* ]]; then
        BASEBRANCH="release"
    else
        BASEBRANCH="main"
    fi
    git -C "$SHARED_BARE_BLAME_ROOT" show-ref --verify --quiet "refs/heads/${BRANCH}" || git -C "$SHARED_BARE_BLAME_ROOT" branch "${BRANCH}" "${BASEBRANCH}"
    build-blame "$SHARED_BARE_GIT_ROOT" "$SHARED_BARE_BLAME_ROOT" --blame-ref="refs/heads/$BRANCH" --old-cinnabar-repo-path "$SHARED_BARE_OLDGIT_ROOT"
    LASTBRANCH="${BRANCH}"
done

date
